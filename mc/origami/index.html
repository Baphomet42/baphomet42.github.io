<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/main/style.css">
    <link rel="stylesheet" href="/mc/style.css">
    <link rel="icon" type="image/x-icon" href="https://avatars.githubusercontent.com/u/71295013?v=4">
    <link rel="apple-touch-icon" href="https://avatars.githubusercontent.com/u/71295013?v=4">
    <title>Origami | BaphomethLabs</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <script src="/template/data-include.js"></script>
</head>
<body>
    <article>
        <div data-include="/mc/header" id="header"></div>

        <table class="card-table"><tr class="card-table-row">

            <td class="card-wrap-mid"><div class="card tooltip center">
                <p class="item-header">Origami</p>
                <br/>
                <p class="item-header warn" style="color:#FFFF55">W.I.P.</p>
                <br/>
                <p class="item-subtitle">Printable Minecraft skin tool</p>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Skin Options</p>
                <br/>
                <table class="card-table">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="skin-source">Source:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="skin-source" onchange="setSkinSource(this.value)" style="font-size:large">
                                <option value="username">Username</option>
                                <option value="file">File</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="skin-source-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="skin-source-file-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="file-input">File:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input type="file" id="file-input" style="display: none;"/>
                            <button class="button" onClick="openFile()" style="font-size:x-large">Select Skin</button>
                        </td>
                        <td class="card-wrap-third">
                            <span id="file-label"></span>
                        </td>
                    </tr>
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="model">Model:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="model" style="font-size:large">
                                <option value="wide">Wide</option>
                                <option value="slim">Slim</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="model-label"></span>
                        </td>
                    </tr>
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                </table>
                <table class="card-table" id="skin-source-username-mode" style="display: none;">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="username-input">Username:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input id="username-input" onkeydown="if(event.key==='Enter') submitAndScroll();" class="large-input" style="font-size:large"/>
                        </td>
                        <td class="card-wrap-third">
                            <span id="username-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="shift-3d">Offset 3D layer:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="shift-3d" style="font-size:large">
                                <option value="none">Off</option>
                                <option value="head">Head</option>
                                <option value="all">All</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="shift-label"></span>
                        </td>
                    </tr>
                </table>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Cape Options</p>
                <br/>
                <table class="card-table">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="cape-source">Source:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="cape-source" onchange="setCapeSource(this.value)" style="font-size:large">
                                <option value="username">Username</option>
                                <option value="preset">Preset</option>
                                <option value="file">File</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="cape-source-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-file-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="file-cape-input">File:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input type="file" id="file-cape-input" style="display: none;"/>
                            <button class="button" onClick="openFileCape()" style="font-size:x-large">Select Cape</button>
                            <button class="button" onClick="clearCape()" style="font-size:x-large">Clear</button>
                        </td>
                        <td class="card-wrap-third">
                            <span id="file-cape-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-username-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third"></td>
                        <td class="card-wrap-third">
                            <span>Cape will be fetched from the username set above, if present</span>
                        </td>
                        <td class="card-wrap-third"></td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-preset-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="cape-preset-input">Cape:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="cape-preset-input" style="font-size:large">
                                <option value="none">No cape</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="cape-preset-label"></span>
                        </td>
                    </tr>
                </table>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Output</p>
                <br/>
                <table class="card-table">
                    <tr class="card-table-row">
                        <td class="card-wrap-third"></td>
                        <td class="card-wrap-third">
                            <button class="button" onClick="submit()" style="font-size:x-large">Generate</button>
                        </td>
                        <td class="card-wrap-third"></td>
                    </tr>
                </table>
                <br/>
                <span id="button-label" class="error"></span>
                <div>
                    <canvas id="canvas" style="display: none"></canvas>
                    <span id="img-span"></span>
                </div>

            </div></td>

        </tr></table>

    </article>
    <div data-include="/template/footer" id="footer"></div>

    <script>
        const vanillaSkinWidth = 64
        const vanillaSkinHeight = 64
        const vanillaSkinHeightOld = 32
        const vanillaCapeWidth = 64
        const vanillaCapeHeight = 32
        const hdScale = 2
        const skinSizes = ''+(vanillaSkinWidth)+'x'+(vanillaSkinHeight)+', '+(hdScale * vanillaSkinWidth)+'x'+(hdScale * vanillaSkinHeight)+', '+(vanillaSkinWidth)+'x'+(vanillaSkinHeightOld)+', or '+(hdScale * vanillaSkinWidth)+'x'+(hdScale * vanillaSkinHeightOld)
        const capeSizes = ''+(vanillaCapeWidth)+'x'+(vanillaCapeHeight)+' or '+(hdScale * vanillaCapeWidth)+'x'+(hdScale * vanillaCapeHeight)

        const apiServer = 'https://silcrow-209748932377.us-central1.run.app/api'

        const pixelScale = 40 // must be even
        const outputWidthBase = 8.5
        const outputHeightBase = 11
        const outputScale = 350
        const outputWidth = Math.floor(outputWidthBase * outputScale)
        const outputHeight = Math.floor(outputHeightBase * outputScale)

        let selectedSkinFileImg = new Image()
        let selectedSkinFileName = ''
        let selectedCapeFileImg = new Image()
        let selectedCapeFileName = ''
        let selectedCapeFileSet = false
        let downloadLink = document.createElement('a')
        let hasOutput = false

        refreshCapePresets()
        setSkinSource('username')
        setCapeSource('username')

        function setSkinSource(source) {
            document.getElementById('skin-source-file-mode').style.display = "none"
            document.getElementById('skin-source-username-mode').style.display = "none"
            if(source === "username")
                document.getElementById('skin-source-username-mode').style.display = ""
            else
                document.getElementById('skin-source-file-mode').style.display = ""
        }

        function setCapeSource(source) {
            document.getElementById('cape-source-file-mode').style.display = "none"
            document.getElementById('cape-source-username-mode').style.display = "none"
            document.getElementById('cape-source-preset-mode').style.display = "none"
            if(source === "username")
                document.getElementById('cape-source-username-mode').style.display = ""
            else if(source === "preset")
                document.getElementById('cape-source-preset-mode').style.display = ""
            else
                document.getElementById('cape-source-file-mode').style.display = ""
        }

        async function refreshCapePresets() {
            const dropdown = document.getElementById('cape-preset-input')
            const prev = dropdown.value

            dropdown.innerHTML = ''
            let optionCount = 0

            const optionNone = document.createElement('option')
            optionNone.text = 'No cape'
            optionNone.value = 'none'
            dropdown.add(optionNone)

            try {
                const response = await fetch('../blackmarket/items.json')

                if (!response.ok) {
                    console.warn('Could not load JSON file:', response.statusText)
                    return
                }

                const data = await response.json()

                if (!data.capes || !Array.isArray(data.capes)) {
                    console.warn('JSON format unexpected: "capes" key missing or not an array')
                    return
                }

                data.capes.forEach(cape => {
                    if (!cape.name || !cape.url)
                        return

                    optionCount++
                    const option = document.createElement('option')
                    option.text = cape.name
                    option.value = cape.url
                    dropdown.add(option)
                })

                // Restore previous selection if it still exists
                if ([...dropdown.options].some(opt => opt.value === prev)) {
                    dropdown.value = prev
                } else {
                    dropdown.value = 'none'
                }

                let lbl = ''
                if(optionCount === 0)
                    lbl = '<span class="error">Failed to fetch cape presets</span>'
                document.getElementById('cape-preset-label').innerHTML = lbl

            } catch (err) {
                console.error('Error reading or parsing JSON:', err)
            }


        }

        function convertUrlHttps(url) {
            if(typeof url !== 'string')
                return null
            if(url.startsWith('http:'))
                return 'https:' + url.substring(5)
            return url
        }

        function testValidSkinSize(width, height) {
            return (
                (
                    height === width
                    ||
                    height * 2 === width
                )
                &&
                (
                    width === vanillaSkinWidth
                    ||
                    width === (hdScale * vanillaSkinWidth)
                )
            )
        }

        function testValidCapeSize(width, height) {
            return (
                (
                    height * 2 === width
                )
                &&
                (
                    width === vanillaCapeWidth
                    ||
                    width === (hdScale * vanillaCapeWidth)
                )
            )
        }

        function openFile() {
            document.getElementById('file-input').click()
        }

        function openFileCape() {
            document.getElementById('file-cape-input').click()
        }

        function clearCape() {
            selectedCapeFileName = ''
            document.getElementById('file-cape-label').innerHTML = ''
            document.getElementById('file-cape-input').value = ''
            selectedCapeFileSet = false
        }

        document.getElementById('file-input').addEventListener('change', function(event) {
            const file = event.target.files[0]
            let valid = false
            document.getElementById('file-label').innerHTML = ''
            document.getElementById('file-input').value = ''

            if(file && file.type === 'image/png') {
                valid = true
                selectedSkinFileName = file.name

                const fr = new FileReader()

                fr.onload = function(e) {
                    selectedSkinFileImg.src = e.target.result
                }

                fr.readAsDataURL(file)
            }

            if(!valid) {
                document.getElementById('file-label').innerHTML = 'File must be a '+skinSizes+' PNG'
            }

        })

        document.getElementById('file-cape-input').addEventListener('change', function(event) {
            selectedCapeFileSet = true

            const file = event.target.files[0]
            let valid = false
            document.getElementById('file-cape-label').innerHTML = ''
            document.getElementById('file-cape-input').value = ''

            if(file && file.type === 'image/png') {
                valid = true
                selectedCapeFileName = file.name

                const fr = new FileReader()

                fr.onload = function(e) {
                    selectedCapeFileImg.src = e.target.result
                }

                fr.readAsDataURL(file)
            }

            if(!valid) {
                document.getElementById('file-cape-label').innerHTML = 'File must be a '+capeSizes+' PNG'
            }

        })

        selectedSkinFileImg.onload = function() {
            document.getElementById('file-label').innerHTML = ''
            if(testValidSkinSize(selectedSkinFileImg.width,selectedSkinFileImg.height)) {
                document.getElementById('file-label').innerHTML = selectedSkinFileName+' ('+selectedSkinFileImg.width+'&#8203;x&#8203;'+selectedSkinFileImg.height+')'
            }
            else {
                document.getElementById('file-label').innerHTML = 'File must be a '+skinSizes+' PNG'
            }
        }

        selectedCapeFileImg.onload = function() {
            document.getElementById('file-cape-label').innerHTML = ''
            if(testValidCapeSize(selectedCapeFileImg.width,selectedCapeFileImg.height)) {
                document.getElementById('file-cape-label').innerHTML = selectedCapeFileName+' ('+selectedCapeFileImg.width+'&#8203;x&#8203;'+selectedCapeFileImg.height+')'
            }
            else {
                document.getElementById('file-cape-label').innerHTML = 'File must be a '+capeSizes+' PNG'
            }
        }

        function submitAndScroll() {
            document.getElementById('button-label').scrollIntoView({block: 'start', behavior: 'smooth'})
            submit()
        }

        async function submit() {
            console.log('Origami generate function started')
            document.getElementById('button-label').innerHTML = ''
            downloadLink = document.createElement('a')

            if(hasOutput) {
                const tempCanvas = document.createElement('canvas')
                tempCanvas.width = outputWidth
                tempCanvas.height = outputHeight
                let tempCanvasHtml = '<img src="'+tempCanvas.toDataURL('image/png')+'" class="img-full">'
                tempCanvasHtml += '<br/><br/>'
                tempCanvasHtml += '<button class="button" style="font-size:x-large" disabled>Download</button>'
                document.getElementById('img-span').innerHTML = tempCanvasHtml
            }
            else {
                document.getElementById('img-span').innerHTML = ''
            }

            let skinValid = false
            let capeValid = false
            let lbl = ''

            let outputFileName = 'download'
            let imgSkin = new Image()
            let slim = false
            let hasCape = false
            let imgCape = new Image()
            let usernameMode = false
            let fetchedProfileCapeExists = false
            let fetchedProfileCapeImg = new Image()

            const skinMode = document.getElementById('skin-source').value
            const capeMode = document.getElementById('cape-source').value

            if(skinMode === 'file') {
                if(!testValidSkinSize(selectedSkinFileImg.width,selectedSkinFileImg.height))
                    lbl = 'Skin must be a '+skinSizes+' PNG'
                else {
                    skinValid = true
                    outputFileName = selectedSkinFileName
                    if(outputFileName.endsWith(".png") && outputFileName.length > 4)
                        outputFileName = outputFileName.substring(0,outputFileName.length - 4)
                    imgSkin = selectedSkinFileImg
                    slim = document.getElementById('model').value === 'slim'
                }
            }
            else if(skinMode === 'username') {
                usernameMode = true
                let username = ''
                let accessedApi = false

                try {
                    username = document.getElementById('username-input').value.trim()
                    if(username === '') {
                        lbl = 'Enter a username'
                    }
                    else if (/^[A-Za-z0-9_]+$/.test(username)) {
                        document.getElementById('button-label').innerHTML = 'Fetching profile...'
                        try {
                            const propertiesResponse = await fetch(apiServer + '/minecraft/properties/name/' + username)
                            if (propertiesResponse.ok) {
                                const propertiesData = await propertiesResponse.json()
                                try {
                                    if(propertiesData && typeof propertiesData === "object" && !Array.isArray(propertiesData))
                                        accessedApi = true
                                } catch {}

                                if (propertiesData.textures && propertiesData.textures.SKIN && propertiesData.textures.SKIN.url) {
                                    const skinUrl = convertUrlHttps(propertiesData.textures.SKIN.url)
                                    const model = propertiesData.textures.SKIN.metadata?.model // optional
                                    const capeUrl = convertUrlHttps(propertiesData.textures.CAPE?.url) // optional

                                    if(model === 'slim')
                                        slim = true

                                    if(skinUrl) {
                                        try {
                                            const parsedUrl = new URL(skinUrl)
                                            if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                                try {
                                                    const response = await fetch(skinUrl)
                                                    if (response.ok) {
                                                        const contentType = response.headers.get("content-type") || ""
                                                        const blob = await response.blob()

                                                        // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                                        const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                                            && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                                .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                                        if (contentType.includes("image/png") || isPngHeader) {
                                                            const objectUrl = URL.createObjectURL(blob)
                                                            await new Promise((resolve, reject) => {
                                                                imgSkin.onload = () => {
                                                                    URL.revokeObjectURL(objectUrl)
                                                                    resolve(true)

                                                                    if (!testValidSkinSize(imgSkin.width,imgSkin.height))
                                                                        lbl = 'Skin must be a '+skinSizes+' PNG'
                                                                    else
                                                                        skinValid = true
                                                                }
                                                                imgSkin.onerror = () => {
                                                                    URL.revokeObjectURL(objectUrl)
                                                                    reject(false)
                                                                }
                                                                imgSkin.src = objectUrl
                                                            })
                                                        }
                                                    }
                                                } catch {}
                                            }
                                        } catch {}
                                    }

                                    if(capeUrl) {
                                        fetchedProfileCapeExists = true
                                        try {
                                            const parsedUrl = new URL(capeUrl)
                                            if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                                try {
                                                    const response = await fetch(capeUrl)
                                                    if (response.ok) {
                                                        const contentType = response.headers.get("content-type") || ""
                                                        const blob = await response.blob()

                                                        // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                                        const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                                            && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                                .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                                        if (contentType.includes("image/png") || isPngHeader) {
                                                            const objectUrl = URL.createObjectURL(blob)
                                                            await new Promise((resolve, reject) => {
                                                                fetchedProfileCapeImg.onload = () => {
                                                                    URL.revokeObjectURL(objectUrl)
                                                                    resolve(true)
                                                                }
                                                                fetchedProfileCapeImg.onerror = () => {
                                                                    URL.revokeObjectURL(objectUrl)
                                                                    reject(false)
                                                                }
                                                                fetchedProfileCapeImg.src = objectUrl
                                                            })
                                                        }
                                                    }
                                                } catch {}
                                            }
                                        } catch {}
                                    }
                                }
                            }
                        } catch {}
                    }
                    else {
                        lbl = 'Invalid username'
                    }
                } catch {}

                if(lbl === '') {
                    if(!accessedApi)
                        lbl = 'Failed to access skin server proxy'
                    else if(!skinValid)
                        lbl = 'Failed to fetch username: ' + username
                }

                document.getElementById('button-label').innerHTML = ''
            }
            else {
                lbl = 'Failed to determine skin source'
            }

            if(skinValid) {
                if(capeMode === 'file') {
                    if(selectedCapeFileSet && !testValidCapeSize(selectedCapeFileImg.width,selectedCapeFileImg.height))
                        lbl = 'Cape must be a '+capeSizes+' PNG'
                    else {
                        capeValid = true
                        hasCape = selectedCapeFileSet
                        imgCape = selectedCapeFileImg
                    }
                }
                else if(capeMode === 'username') {
                    if(usernameMode) {
                        if(fetchedProfileCapeExists) {
                            if (!testValidCapeSize(fetchedProfileCapeImg.width,fetchedProfileCapeImg.height))
                                lbl = 'Cape must be a '+capeSizes+' PNG'
                            else {
                                capeValid = true
                                hasCape =  true
                                imgCape = fetchedProfileCapeImg
                            }
                        }
                        else {
                            capeValid = true
                            hasCape = false
                        }
                    }
                    else {
                        capeValid = true
                        hasCape = false
                    }
                }
                else if(capeMode === 'preset') {
                    const url = document.getElementById('cape-preset-input').value
                    if(url === 'none') {
                        capeValid = true
                        hasCape = false
                    }
                    else {
                        document.getElementById('button-label').innerHTML = 'Fetching cape...'

                        try {
                            const capeUrl = convertUrlHttps(url)
                            const parsedUrl = new URL(capeUrl)
                            if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                try {
                                    const response = await fetch(capeUrl)
                                    if (response.ok) {
                                        const contentType = response.headers.get("content-type") || ""
                                        const blob = await response.blob()

                                        // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                        const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                            && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                        if (contentType.includes("image/png") || isPngHeader) {
                                            const objectUrl = URL.createObjectURL(blob)
                                            await new Promise((resolve, reject) => {
                                                imgCape.onload = () => {
                                                    URL.revokeObjectURL(objectUrl)
                                                    resolve(true)

                                                    if (!testValidCapeSize(imgCape.width,imgCape.height))
                                                        lbl = 'Cape must be a '+capeSizes+' PNG'
                                                    else {
                                                        capeValid = true
                                                        hasCape = true
                                                    }
                                                }
                                                imgCape.onerror = () => {
                                                    URL.revokeObjectURL(objectUrl)
                                                    reject(false)
                                                }
                                                imgCape.src = objectUrl
                                            })
                                        }
                                    }
                                } catch {}
                            }
                        } catch {}

                        if(!capeValid && lbl === '') {
                            lbl = 'Failed to fetch preset cape: ' + document.getElementById('cape-preset-input').selectedOptions[0].text
                        }

                        document.getElementById('button-label').innerHTML = ''
                    }
                }
                else {
                    lbl = 'Failed to determine cape source'
                }
            }

            if(lbl === '' && !(skinValid && capeValid))
                lbl = 'Failed to validate inputs'

            document.getElementById('button-label').innerHTML = lbl

            if(skinValid && capeValid) {
                console.log('Inputs validated')
                document.getElementById('button-label').innerHTML = 'Loading...'

                console.log('Skin size: '+imgSkin.width+'x'+imgSkin.height)

                if ((imgSkin.width !== imgSkin.height)) {
                    // see net.minecraft.client.renderer.texture.SkinTextureDownloader
                    console.log('Legacy skin detected, converting to new format')
                    const oldSkinResizeCanvas = document.createElement('canvas')
                    oldSkinResizeCanvas.width = imgSkin.width
                    oldSkinResizeCanvas.height = imgSkin.width
                    const ctx = oldSkinResizeCanvas.getContext('2d', { willReadFrequently: true })

                    ctx.drawImage(imgSkin, 0, 0)

                    const imageData = ctx.getImageData(imgSkin.width / 2, 0, imgSkin.width / 2, imgSkin.width / 2)
                    let hasTransparency = false
                    for (let i = 3; i < imageData.data.length; i += 4) {
                        if (imageData.data[i] < 128) {
                            hasTransparency = true
                            break
                        }
                    }

                    if (!hasTransparency) {
                        console.log('Archaic skin detected, removing hat layer')
                        const hatData = ctx.getImageData(imgSkin.width / 2, 0, imgSkin.width / 2, imgSkin.width / 4)
                        for (let i = 0; i < hatData.data.length; i += 4) {
                            hatData.data[i] = 0
                            hatData.data[i+1] = 0
                            hatData.data[i+2] = 0
                            hatData.data[i+3] = 0
                        }
                        ctx.putImageData(hatData, imgSkin.width / 2, 0)
                    }

                    const legacyCoordScale = imgSkin.width / vanillaSkinWidth

                    function copyRegion(inpSrcX, inpSrcY, inpDestDX, inpDestDY, inpWidth, inpHeight, mirrorX = false, mirrorY = false) {
                        const srcX = inpSrcX * legacyCoordScale
                        const srcY = inpSrcY * legacyCoordScale
                        const destDX = inpDestDX * legacyCoordScale
                        const destDY = inpDestDY * legacyCoordScale
                        const width = inpWidth * legacyCoordScale
                        const height = inpHeight * legacyCoordScale

                        const imageData = ctx.getImageData(srcX, srcY, width, height);
                        const out = ctx.createImageData(width, height);
                        const src = imageData.data;
                        const dst = out.data;

                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const srcIndex = (y * width + x) * 4;
                                const dstX = mirrorX ? width - 1 - x : x;
                                const dstY = mirrorY ? height - 1 - y : y;
                                const dstIndex = (dstY * width + dstX) * 4;
                                dst[dstIndex] = src[srcIndex];
                                dst[dstIndex + 1] = src[srcIndex + 1];
                                dst[dstIndex + 2] = src[srcIndex + 2];
                                dst[dstIndex + 3] = src[srcIndex + 3];
                            }
                        }

                        ctx.putImageData(out, srcX + destDX, srcY + destDY);
                    }

                    copyRegion(4, 16, 16, 32, 4, 4, true, false)
                    copyRegion(8, 16, 16, 32, 4, 4, true, false)
                    copyRegion(0, 20, 24, 32, 4, 12, true, false)
                    copyRegion(4, 20, 16, 32, 4, 12, true, false)
                    copyRegion(8, 20, 8, 32, 4, 12, true, false)
                    copyRegion(12, 20, 16, 32, 4, 12, true, false)
                    copyRegion(44, 16, -8, 32, 4, 4, true, false)
                    copyRegion(48, 16, -8, 32, 4, 4, true, false)
                    copyRegion(40, 20, 0, 32, 4, 12, true, false)
                    copyRegion(44, 20, -8, 32, 4, 12, true, false)
                    copyRegion(48, 20, -16, 32, 4, 12, true, false)
                    copyRegion(52, 20, -8, 32, 4, 12, true, false)

                    imgSkin = await new Promise(resolve => {
                        const newImg = new Image();
                        newImg.onload = () => resolve(newImg);
                        newImg.src = oldSkinResizeCanvas.toDataURL('image/png');
                    })
                }       

                const inputWidth = imgSkin.width
                const inputHeight = imgSkin.height
                const upscale = Math.floor((vanillaSkinWidth*pixelScale) / inputWidth)

                const offset = Math.floor(pixelScale / 4)
                const offset_3d_all = document.getElementById('shift-3d').value === 'all'
                const offset_3d_head = offset_3d_all || document.getElementById('shift-3d').value === 'head'

                const canvasSkin = document.createElement('canvas')
                canvasSkin.width = vanillaSkinWidth*pixelScale
                canvasSkin.height = vanillaSkinHeight*pixelScale
                const srcCtx = canvasSkin.getContext('2d')

                const tmpCanvas = document.createElement('canvas')
                tmpCanvas.width = inputWidth
                tmpCanvas.height = inputHeight
                const tmpCtx = tmpCanvas.getContext('2d')
                tmpCtx.drawImage(imgSkin, 0, 0)
                const originalImageData = tmpCtx.getImageData(0, 0, inputWidth, inputHeight)
                const scaledImageData = srcCtx.createImageData(vanillaSkinWidth*pixelScale, vanillaSkinHeight*pixelScale)

                console.log('Scaling skin')
                for (let y = 0; y < inputHeight; y++) {
                    for (let x = 0; x < inputWidth; x++) {
                        const index = (y * inputWidth + x) * 4
                        const r = originalImageData.data[index]
                        const g = originalImageData.data[index + 1]
                        const b = originalImageData.data[index + 2]
                        const a = originalImageData.data[index + 3]

                        for (let dy = 0; dy < upscale; dy++) {
                            for (let dx = 0; dx < upscale; dx++) {
                                const scaledIndex = ((y * upscale + dy) * vanillaSkinWidth*pixelScale + (x * upscale + dx)) * 4
                                scaledImageData.data[scaledIndex] = r
                                scaledImageData.data[scaledIndex + 1] = g
                                scaledImageData.data[scaledIndex + 2] = b
                                scaledImageData.data[scaledIndex + 3] = a
                            }
                        }
                    }
                }
                srcCtx.putImageData(scaledImageData, 0, 0)

                let canvasCape
                if (hasCape) {
                    console.log('Cape size: '+imgCape.width+'x'+imgCape.height)
                    canvasCape = document.createElement('canvas')
                    canvasCape.width = vanillaCapeWidth*pixelScale
                    canvasCape.height = vanillaCapeHeight*pixelScale
                    const capeCtx = canvasCape.getContext('2d')

                    const capeWidth = imgCape.width
                    const capeHeight = imgCape.height
                    const capeUpscale = Math.floor(vanillaCapeWidth*pixelScale / capeWidth)
                    const tmpCapeCanvas = document.createElement('canvas')
                    tmpCapeCanvas.width = capeWidth
                    tmpCapeCanvas.height = capeHeight
                    const tmpCapeCtx = tmpCapeCanvas.getContext('2d')
                    tmpCapeCtx.drawImage(imgCape, 0, 0)
                    const capeData = tmpCapeCtx.getImageData(0, 0, capeWidth, capeHeight)
                    const scaledCapeData = capeCtx.createImageData(vanillaCapeWidth*pixelScale, vanillaCapeHeight*pixelScale)

                    console.log('Scaling cape')
                    for (let y = 0; y < capeHeight; y++) {
                        for (let x = 0; x < capeWidth; x++) {
                            const index = (y * capeWidth + x) * 4
                            const r = capeData.data[index]
                            const g = capeData.data[index + 1]
                            const b = capeData.data[index + 2]
                            const a = capeData.data[index + 3]

                            for (let dy = 0; dy < capeUpscale; dy++) {
                                for (let dx = 0; dx < capeUpscale; dx++) {
                                    const scaledIndex = ((y * capeUpscale + dy) * vanillaCapeWidth*pixelScale + (x * capeUpscale + dx)) * 4
                                    scaledCapeData.data[scaledIndex] = r
                                    scaledCapeData.data[scaledIndex + 1] = g
                                    scaledCapeData.data[scaledIndex + 2] = b
                                    scaledCapeData.data[scaledIndex + 3] = a
                                }
                            }
                        }
                    }
                    capeCtx.putImageData(scaledCapeData, 0, 0)
                }

                const canvas = document.getElementById('canvas')
                canvas.width = outputWidth
                canvas.height = outputHeight
                const ctx = canvas.getContext('2d')
                ctx.clearRect(0, 0, canvas.width, canvas.height)
                ctx.imageSmoothingEnabled = false
                ctx.globalCompositeOperation = 'source-over'

                const spacing = Math.floor(outputWidth / 40)

                const head_x = spacing
                const head_y = spacing
                const body_x = spacing
                const body_y = spacing + (24*pixelScale + spacing)
                const arm_left_x = spacing
                const arm_left_y = spacing + (24*pixelScale + spacing) + (20*pixelScale + spacing)
                const arm_right_x = Math.floor(outputWidth / 2) + spacing
                const arm_right_y = spacing + (24*pixelScale + spacing) + (20*pixelScale + spacing)
                const leg_left_x = spacing
                const leg_left_y = spacing + (24*pixelScale + spacing) + (20*pixelScale + spacing) + (20*pixelScale + spacing)
                const leg_right_x = Math.floor(outputWidth / 2) + spacing
                const leg_right_y = spacing + (24*pixelScale + spacing) + (20*pixelScale + spacing) + (20*pixelScale + spacing)
                const cape_x = Math.floor(outputWidth / 2) + spacing
                const cape_y = spacing + (24*pixelScale + spacing)
                const tab_size = 4
                const tab_small_size = 2

                const ops = [
                    { input: { x: 0, y: 8, dx: 32, dy: 8 }, output: { x: head_x+tab_size*pixelScale, y: head_y+8*pixelScale },
                        background: "0xFF000000", layer: { dx: 32, offset_y: offset_3d_head ? offset : 0 } },
                    { input: { x: 8, y: 0, dx: 8, dy: 8 }, output: { x: head_x+(tab_size+8)*pixelScale, y: head_y },
                        background: "0xFF000000", layer: { dx: 32 } },
                    { input: { x: 16, y: 0, dx: 8, dy: -8 }, output: { x: head_x+(tab_size+8)*pixelScale, y: head_y+16*pixelScale },
                        background: "0xFF000000", layer: { dx: 32 } },
                    { input: { x: 0+24+8-tab_size, y: 8, dx: tab_size, dy: 8 }, output: { x: head_x, y: head_y+8*pixelScale },
                        background: "0xFF000000", layer: { dx: 32, offset_y: offset_3d_head ? offset : 0 } },

                    { input: { x: 16, y: 20, dx: 24, dy: 12 }, output: { x: body_x+tab_size*pixelScale, y: body_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },
                    { input: { x: 20, y: 16, dx: 8, dy: 4 }, output: { x: body_x+(tab_size+4)*pixelScale, y: body_y },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 28, y: 16, dx: 8, dy: -4 }, output: { x: body_x+(tab_size+4)*pixelScale, y: body_y+16*pixelScale },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 16+16+8-tab_size, y: 20, dx: tab_size, dy: 12 }, output: { x: body_x, y: body_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },

                    { input: { x: 40, y: 20, dx: 16 - (slim ? 2 : 0), dy: 12 }, output: { x: arm_right_x+tab_small_size*pixelScale, y: arm_right_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },
                    { input: { x: 44, y: 16, dx: 4 - (slim ? 1 : 0), dy: 4 }, output: { x: arm_right_x+(tab_small_size+4)*pixelScale, y: arm_right_y },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 48 - (slim ? 1 : 0), y: 16, dx: 4 - (slim ? 1 : 0), dy: -4 }, output: { x: arm_right_x+(tab_small_size+4)*pixelScale, y: arm_right_y+16*pixelScale },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 40+12+4-tab_small_size-(slim ? 2 : 0), y: 20, dx: tab_small_size, dy: 12 }, output: { x: arm_right_x, y: arm_right_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },

                    { input: { x: 32, y: 52, dx: 16 - (slim ? 2 : 0), dy: 12 }, output: { x: arm_left_x+tab_small_size*pixelScale, y: arm_left_y+4*pixelScale },
                        background: "0xFF000000", layer: { dx: 16, offset_y: offset_3d_all ? offset : 0 } },
                    { input: { x: 36, y: 48, dx: 4 - (slim ? 1 : 0), dy: 4 }, output: { x: arm_left_x+(tab_small_size+4)*pixelScale, y: arm_left_y },
                        background: "0xFF000000", layer: { dx: 16 } },
                    { input: { x: 40 - (slim ? 1 : 0), y: 48, dx: 4 - (slim ? 1 : 0), dy: -4 }, output: { x: arm_left_x+(tab_small_size+4)*pixelScale, y: arm_left_y+16*pixelScale },
                        background: "0xFF000000", layer: { dx: 16 } },
                    { input: { x: 32+12+4-tab_small_size-(slim ? 2 : 0), y: 52, dx: tab_small_size, dy: 12 }, output: { x: arm_left_x, y: arm_left_y+4*pixelScale },
                        background: "0xFF000000", layer: { dx: 16, offset_y: offset_3d_all ? offset : 0 } },

                    { input: { x: 0, y: 20, dx: 16, dy: 12 }, output: { x: leg_right_x+tab_small_size*pixelScale, y: leg_right_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },
                    { input: { x: 4, y: 16, dx: 4, dy: 4 }, output: { x: leg_right_x+(tab_small_size+4)*pixelScale, y: leg_right_y },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 8, y: 16, dx: 4, dy: -4 }, output: { x: leg_right_x+(tab_small_size+4)*pixelScale, y: leg_right_y+16*pixelScale },
                        background: "0xFF000000", layer: { dy: 16 } },
                    { input: { x: 0+12+4-tab_small_size, y: 20, dx: tab_small_size, dy: 12 }, output: { x: leg_right_x, y: leg_right_y+4*pixelScale },
                        background: "0xFF000000", layer: { dy: 16, offset_y: offset_3d_all ? offset : 0 } },

                    { input: { x: 16, y: 52, dx: 16, dy: 12 }, output: { x: leg_left_x+tab_small_size*pixelScale, y: leg_left_y+4*pixelScale },
                        background: "0xFF000000", layer: { dx: -16, offset_y: offset_3d_all ? offset : 0  } },
                    { input: { x: 20, y: 48, dx: 4, dy: 4 }, output: { x: leg_left_x+(tab_small_size+4)*pixelScale, y: leg_left_y },
                        background: "0xFF000000", layer: { dx: -16 } },
                    { input: { x: 24, y: 48, dx: 4, dy: -4 }, output: { x: leg_left_x+(tab_small_size+4)*pixelScale, y: leg_left_y+16*pixelScale },
                        background: "0xFF000000", layer: { dx: -16 } },
                    { input: { x: 16+12+4-tab_small_size, y: 52, dx: tab_small_size, dy: 12 }, output: { x: leg_left_x, y: leg_left_y+4*pixelScale },
                        background: "0xFF000000", layer: { dx: -16, offset_y: offset_3d_all ? offset : 0  } },

                    {  file:"cape", input: { x: 0, y: 1, dx: 22, dy: 16 }, output: { x: cape_x+tab_size*pixelScale, y: cape_y+1*pixelScale },
                        background: "0xFF000000" },
                    {  file:"cape", input: { x: 1, y: 0, dx: 10, dy: 1 }, output: { x: cape_x+(tab_size+1)*pixelScale, y: cape_y },
                        background: "0xFF000000" },
                    {  file:"cape", input: { x: 11, y: 0, dx: 10, dy: -1 }, output: { x: cape_x+(tab_size+1)*pixelScale, y: cape_y+17*pixelScale },
                        background: "0xFF000000" },
                    {  file:"cape", input: { x: 0+12+10-tab_size, y: 1, dx: tab_size, dy: 16 }, output: { x: cape_x, y: cape_y+1*pixelScale },
                        background: "0xFF000000" },
                ]

                console.log('Drawing canvas')
                for (const op of ops) {
                    if (op.file === "cape" && !hasCape)
                        continue
                    if(op.input.dx === 0 || op.input.dy === 0)
                        continue

                    const sourceCanvas = op.file === "cape" ? canvasCape : canvasSkin

                    const inputX = op.input.x * pixelScale
                    const inputY = op.input.y * pixelScale
                    const inputW = op.input.dx * pixelScale
                    const inputH = op.input.dy * pixelScale

                    const outputX = op.output.x
                    const outputY = op.output.y
                    const outputW = Math.abs(inputW)
                    const outputH = Math.abs(inputH)

                    ctx.save()
                    ctx.beginPath()
                    ctx.rect(outputX, outputY, outputW, outputH)
                    ctx.clip()

                    ctx.translate(outputX + (inputW < 0 ? outputW : 0), outputY + (inputH < 0 ? outputH : 0))
                    ctx.scale(inputW < 0 ? -1 : 1, inputH < 0 ? -1 : 1)

                    if (op.background) {
                        const argb = parseInt(op.background)
                        const a = ((argb >> 24) & 0xFF) / 255
                        const r = (argb >> 16) & 0xFF
                        const g = (argb >> 8) & 0xFF
                        const b = argb & 0xFF
                        ctx.fillStyle = `rgba(${r},${g},${b},${a})`
                        ctx.fillRect(0, 0, outputW, outputH)
                    }

                    {
                        const tempCanvas = document.createElement('canvas')
                        tempCanvas.width = outputW
                        tempCanvas.height = outputH
                        const tempCtx = tempCanvas.getContext('2d')

                        tempCtx.drawImage(sourceCanvas, inputX, inputY, outputW, outputH, 0, 0, outputW, outputH)

                        const imgData = tempCtx.getImageData(0, 0, outputW, outputH)
                        for (let i = 3; i < imgData.data.length; i += 4) {
                            imgData.data[i] = 255
                        }
                        tempCtx.putImageData(imgData, 0, 0)

                        ctx.drawImage(tempCanvas, 0, 0)
                    }

                    if (op.layer) {
                        const layerInputX = (op.input.x + (op.layer.dx ?? 0)) * pixelScale
                        const layerInputY = (op.input.y + (op.layer.dy ?? 0)) * pixelScale
                        const layerOffsetX = op.layer.offset_x ?? 0
                        const layerOffsetY = op.layer.offset_y ?? 0

                        ctx.drawImage(sourceCanvas, layerInputX, layerInputY, outputW, outputH, layerOffsetX, layerOffsetY, outputW, outputH)
                    }

                    ctx.restore()
                }

                hasOutput = true
                downloadLink.href = canvas.toDataURL('image/png')
                downloadLink.download = outputFileName + ".png"
                let newHtml = '<img src="'+canvas.toDataURL('image/png')+'" class="img-full">'
                newHtml += '<br/><br/>'
                newHtml += '<button class="button" onClick="download()" style="font-size:x-large">Download</button>'
                document.getElementById('img-span').innerHTML = newHtml
                document.getElementById('button-label').innerHTML = ''
                console.log('Generate function completed')
            }
            else {
                if(lbl === '')
                    console.log('Inputs invalid')
                else
                    console.log('Inputs invalid: '+lbl)
                hasOutput = false
                document.getElementById('img-span').innerHTML = ''
            }
        }

        function download() {
            downloadLink.click()
        }

    </script>

</body>
</html>