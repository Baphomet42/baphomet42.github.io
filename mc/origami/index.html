<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/main/style.css">
    <link rel="stylesheet" href="/mc/style.css">
    <link rel="icon" type="image/x-icon" href="https://avatars.githubusercontent.com/u/71295013?v=4">
    <link rel="apple-touch-icon" href="https://avatars.githubusercontent.com/u/71295013?v=4">
    <title>Origami | BaphomethLabs</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
    <script src="/template/data-include.js"></script>
</head>
<body>
    <article>
        <div data-include="/mc/header" id="header"></div>

        <table class="card-table"><tr class="card-table-row">

            <td class="card-wrap-mid"><div class="card tooltip center">
                <p class="item-header">Origami</p>
                <br/>
                <p class="item-subtitle">Generate a PDF to print a 3D Minecraft skin</p>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Skin Options</p>
                <br/>
                <table class="card-table">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="skin-source">Source:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="skin-source" onchange="setSkinSource(this.value)" style="font-size:large">
                                <option value="username">Username</option>
                                <option value="file">File</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="skin-source-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="skin-source-file-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="file-input">File:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input type="file" id="file-input" style="display: none;"/>
                            <button class="button" onClick="openFile()" style="font-size:x-large">Select Skin</button>
                        </td>
                        <td class="card-wrap-third">
                            <span id="file-label"></span>
                        </td>
                    </tr>
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="model">Model:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="model" style="font-size:large">
                                <option value="wide">Wide</option>
                                <option value="slim">Slim</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="model-label"></span>
                        </td>
                    </tr>
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                </table>
                <table class="card-table" id="skin-source-username-mode" style="display: none;">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="username-input">Username:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input id="username-input" onkeydown="if(event.key==='Enter') submitAndScroll();" class="large-input" style="font-size:large"/>
                        </td>
                        <td class="card-wrap-third">
                            <span id="username-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="shift-3d">Offset 3D layer:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="shift-3d" style="font-size:large">
                                <option value="all">All</option>
                                <option value="head">Head</option>
                                <option value="none">Off</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="shift-label"></span>
                        </td>
                    </tr>
                </table>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Cape Options</p>
                <br/>
                <table class="card-table">
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="cape-source">Source:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="cape-source" onchange="setCapeSource(this.value)" style="font-size:large">
                                <option value="username">Username</option>
                                <option value="preset">Preset</option>
                                <option value="file">File</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="cape-source-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-file-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="file-cape-input">File:</label>
                        </td>
                        <td class="card-wrap-third">
                            <input type="file" id="file-cape-input" style="display: none;"/>
                            <button class="button" onClick="openFileCape()" style="font-size:x-large">Select Cape</button>
                            <button class="button" onClick="clearCape()" style="font-size:x-large">Clear</button>
                        </td>
                        <td class="card-wrap-third">
                            <span id="file-cape-label"></span>
                        </td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-username-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third"></td>
                        <td class="card-wrap-third">
                            <span>Cape will be fetched from the username set above, if present</span>
                        </td>
                        <td class="card-wrap-third"></td>
                    </tr>
                </table>
                <table class="card-table" id="cape-source-preset-mode" style="display: none;">
                    <tr class="card-table-row"><td class="card-wrap-full"><br/></td></tr>
                    <tr class="card-table-row">
                        <td class="card-wrap-third">
                            <label for="cape-preset-input">Cape:</label>
                        </td>
                        <td class="card-wrap-third">
                            <select id="cape-preset-input" style="font-size:large">
                                <option value="none">No cape</option>
                            </select>
                        </td>
                        <td class="card-wrap-third">
                            <span id="cape-preset-label"></span>
                        </td>
                    </tr>
                </table>
            </div></td>

            <td class="card-wrap-full"><div class="card tooltip center">
                <p class="item-header">Output</p>
                <br/>
                <br/>
                <br/>
                <button class="button" onClick="submit()" style="font-size:x-large">Generate</button>
                <br/>
                <br/>
                <br/>
                <span id="button-label" class="error"></span>
                <div>
                    <canvas id="canvas" style="display: none"></canvas>
                    <span id="img-span"></span>
                </div>

            </div></td>

        </tr></table>

    </article>
    <div data-include="/template/footer" id="footer"></div>

    <script>
        const vanillaSkinWidth = 64
        const vanillaSkinHeight = 64
        const vanillaSkinHeightOld = 32
        const vanillaCapeWidth = 64
        const vanillaCapeHeight = 32
        const hdScale = 2
        const skinSizes = ''+(vanillaSkinWidth)+'x'+(vanillaSkinHeight)+', '+(hdScale * vanillaSkinWidth)+'x'+(hdScale * vanillaSkinHeight)+', '+(vanillaSkinWidth)+'x'+(vanillaSkinHeightOld)+', or '+(hdScale * vanillaSkinWidth)+'x'+(hdScale * vanillaSkinHeightOld)
        const capeSizes = ''+(vanillaCapeWidth)+'x'+(vanillaCapeHeight)+' or '+(hdScale * vanillaCapeWidth)+'x'+(hdScale * vanillaCapeHeight)

        const apiServer = 'https://silcrow-209748932377.us-central1.run.app/api'

        const pixelScaleInput = 10
        const pixelScale = 4 * pixelScaleInput // must be multiple of 4

        const outputUnitWidth = 8.5
        const outputUnitHeight = 11
        const outputUnitLabel = 'in'
        const outputUnitScale = 350
        const outputWidth = Math.floor(outputUnitWidth * outputUnitScale)
        const outputHeight = Math.floor(outputUnitHeight * outputUnitScale)

        const extrudeEdges = true
        const extrudeAmount = pixelScale // must be integer 0 or higher

        const disableDoubleSided = true

        const spacing = (2 * extrudeAmount) + pixelScale
        const pageMarginX = Math.ceil(outputWidth / 10)
        const pageMarginY = Math.ceil(outputHeight / 10)
        const pageMarginUnitX = pageMarginX / outputUnitScale
        const pageMarginUnitY = pageMarginY / outputUnitScale
        const pageColor = "#FFFFFF"

        const dottedPixelLength = Math.floor(pixelScale / 2)
        const dottedPixelWidth = Math.floor(pixelScale / 4)
        const showDashedLines = !disableDoubleSided
        const dottedColorA = '#00000088'
        const dottedColorB = '#FFFFFF88'
        const solidColor = '#88888888'

        let selectedSkinFileImg = new Image()
        let selectedSkinFileName = ''
        let selectedCapeFileImg = new Image()
        let selectedCapeFileName = ''
        let selectedCapeFileSet = false
        let generatedPdf = null
        let prevPageCount = 0

        refreshCapePresets()
        setSkinSource('username')
        setCapeSource('username')

        function createCanvas(width, height) {
            const c = document.createElement('canvas')
            c.width = width
            c.height = height
            return c
        }

        function getCanvasContext(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true })
            ctx.imageSmoothingEnabled = false
            return ctx
        }

        function setSkinSource(source) {
            document.getElementById('skin-source-file-mode').style.display = "none"
            document.getElementById('skin-source-username-mode').style.display = "none"
            if(source === "username")
                document.getElementById('skin-source-username-mode').style.display = ""
            else
                document.getElementById('skin-source-file-mode').style.display = ""
        }

        function setCapeSource(source) {
            document.getElementById('cape-source-file-mode').style.display = "none"
            document.getElementById('cape-source-username-mode').style.display = "none"
            document.getElementById('cape-source-preset-mode').style.display = "none"
            if(source === "username")
                document.getElementById('cape-source-username-mode').style.display = ""
            else if(source === "preset")
                document.getElementById('cape-source-preset-mode').style.display = ""
            else
                document.getElementById('cape-source-file-mode').style.display = ""
        }

        async function refreshCapePresets() {
            const dropdown = document.getElementById('cape-preset-input')
            const prev = dropdown.value

            dropdown.innerHTML = ''
            let optionCount = 0

            const optionNone = document.createElement('option')
            optionNone.text = 'No cape'
            optionNone.value = 'none'
            dropdown.add(optionNone)

            try {
                const response = await fetch('../blackmarket/items.json')

                if (!response.ok) {
                    console.warn('Could not load JSON file:', response.statusText)
                    return
                }

                const data = await response.json()

                if (!data.capes || !Array.isArray(data.capes)) {
                    console.warn('JSON format unexpected: "capes" key missing or not an array')
                    return
                }

                data.capes.forEach(cape => {
                    if (!cape.name || !cape.url)
                        return

                    optionCount++
                    const option = document.createElement('option')
                    option.text = cape.name
                    option.value = cape.url
                    dropdown.add(option)
                })

                // Restore previous selection if it still exists
                if ([...dropdown.options].some(opt => opt.value === prev)) {
                    dropdown.value = prev
                } else {
                    dropdown.value = 'none'
                }

                let lbl = ''
                if(optionCount === 0)
                    lbl = '<span class="error">Failed to fetch cape presets</span>'
                document.getElementById('cape-preset-label').innerHTML = lbl

            } catch (err) {
                console.error('Error reading or parsing JSON:', err)
            }


        }

        function convertUrlHttps(url) {
            if(typeof url !== 'string')
                return null
            if(url.startsWith('http:'))
                return 'https:' + url.substring(5)
            return url
        }

        function testValidSkinSize(width, height) {
            return (
                (
                    height === width
                    ||
                    height * 2 === width
                )
                &&
                (
                    width === vanillaSkinWidth
                    ||
                    width === (hdScale * vanillaSkinWidth)
                )
            )
        }

        function testValidCapeSize(width, height) {
            return (
                (
                    height * 2 === width
                )
                &&
                (
                    width === vanillaCapeWidth
                    ||
                    width === (hdScale * vanillaCapeWidth)
                )
            )
        }

        function openFile() {
            document.getElementById('file-input').click()
        }

        function openFileCape() {
            document.getElementById('file-cape-input').click()
        }

        function clearCape() {
            selectedCapeFileName = ''
            document.getElementById('file-cape-label').innerHTML = ''
            document.getElementById('file-cape-input').value = ''
            selectedCapeFileSet = false
        }

        document.getElementById('file-input').addEventListener('change', function(event) {
            const file = event.target.files[0]
            let valid = false
            document.getElementById('file-label').innerHTML = ''
            document.getElementById('file-input').value = ''

            if(file && file.type === 'image/png') {
                valid = true
                selectedSkinFileName = file.name

                const fr = new FileReader()

                fr.onload = function(e) {
                    selectedSkinFileImg.src = e.target.result
                }

                fr.readAsDataURL(file)
            }

            if(!valid) {
                document.getElementById('file-label').innerHTML = 'File must be a '+skinSizes+' PNG'
            }

        })

        document.getElementById('file-cape-input').addEventListener('change', function(event) {
            selectedCapeFileSet = true

            const file = event.target.files[0]
            let valid = false
            document.getElementById('file-cape-label').innerHTML = ''
            document.getElementById('file-cape-input').value = ''

            if(file && file.type === 'image/png') {
                valid = true
                selectedCapeFileName = file.name

                const fr = new FileReader()

                fr.onload = function(e) {
                    selectedCapeFileImg.src = e.target.result
                }

                fr.readAsDataURL(file)
            }

            if(!valid) {
                document.getElementById('file-cape-label').innerHTML = 'File must be a '+capeSizes+' PNG'
            }

        })

        selectedSkinFileImg.onload = function() {
            document.getElementById('file-label').innerHTML = ''
            if(testValidSkinSize(selectedSkinFileImg.width,selectedSkinFileImg.height)) {
                document.getElementById('file-label').innerHTML = selectedSkinFileName+' ('+selectedSkinFileImg.width+'&#8203;x&#8203;'+selectedSkinFileImg.height+')'
            }
            else {
                document.getElementById('file-label').innerHTML = 'File must be a '+skinSizes+' PNG'
            }
        }

        selectedCapeFileImg.onload = function() {
            document.getElementById('file-cape-label').innerHTML = ''
            if(testValidCapeSize(selectedCapeFileImg.width,selectedCapeFileImg.height)) {
                document.getElementById('file-cape-label').innerHTML = selectedCapeFileName+' ('+selectedCapeFileImg.width+'&#8203;x&#8203;'+selectedCapeFileImg.height+')'
            }
            else {
                document.getElementById('file-cape-label').innerHTML = 'File must be a '+capeSizes+' PNG'
            }
        }

        async function sleep() {
            return new Promise(r => setTimeout(r, 50))
        }

        async function labelAndLog(element, text) {
            console.log(text)
            await label(element, text)
        }

        async function label(element, text) {
            document.getElementById(element).innerHTML = text
            await sleep()
        }

        function submitAndScroll() {
            document.getElementById('button-label').scrollIntoView({block: 'start', behavior: 'smooth'})
            submit()
        }

        async function submit() {
            try {
                console.log('Origami generate function started')
                generatedPdf = null

                if (prevPageCount >= 1) {
                    const tempCanvas = createCanvas(outputWidth, outputHeight)

                    let newHtml = ''
                    newHtml += '<br/>'
                    newHtml += '<button class="button" onClick="openPdf()" style="font-size:x-large">Open PDF</button>'
                    newHtml += '<br/>'
                    newHtml += '<table class="card-table"><tr class="card-table-row">'
                    for (let i = 0; i < prevPageCount; i++) {
                        newHtml += `<td class="card-wrap-any"><img src="${tempCanvas.toDataURL('image/png')}" class="img-mostly"></td>`
                    }
                    newHtml += '</tr></table>'

                    document.getElementById('img-span').innerHTML = newHtml
                    label('button-label', '')
                }
                else
                    document.getElementById('img-span').innerHTML = ''
                prevPageCount = 0

                await labelAndLog('button-label', 'Validating inputs...')

                let skinValid = false
                let capeValid = false
                let lbl = ''

                let outputFileName = 'download'
                let imgSkin = new Image()
                let slim = false
                let hasCape = false
                let imgCape = new Image()
                let usernameMode = false
                let fetchedProfileCapeExists = false
                let fetchedProfileCapeImg = new Image()

                const skinMode = document.getElementById('skin-source').value
                const capeMode = document.getElementById('cape-source').value

                if(skinMode === 'file') {
                    if(!testValidSkinSize(selectedSkinFileImg.width,selectedSkinFileImg.height))
                        lbl = 'Skin must be a '+skinSizes+' PNG'
                    else {
                        skinValid = true
                        outputFileName = selectedSkinFileName
                        if(outputFileName.endsWith(".png") && outputFileName.length > 4)
                            outputFileName = outputFileName.substring(0,outputFileName.length - 4)
                        imgSkin = selectedSkinFileImg
                        slim = document.getElementById('model').value === 'slim'
                    }
                }
                else if(skinMode === 'username') {
                    usernameMode = true
                    let username = ''
                    let accessedApi = false

                    try {
                        username = document.getElementById('username-input').value.trim()
                        if(username === '') {
                            lbl = 'Enter a username'
                        }
                        else if (/^[A-Za-z0-9_]+$/.test(username)) {
                            await labelAndLog('button-label', 'Fetching profile...')
                            try {
                                const propertiesResponse = await fetch(apiServer + '/minecraft/properties/name/' + username)
                                if (propertiesResponse.ok) {
                                    const propertiesData = await propertiesResponse.json()
                                    try {
                                        if(propertiesData && typeof propertiesData === "object" && !Array.isArray(propertiesData))
                                            accessedApi = true
                                    } catch {}

                                    if (propertiesData.textures && propertiesData.textures.SKIN && propertiesData.textures.SKIN.url) {
                                        const skinUrl = convertUrlHttps(propertiesData.textures.SKIN.url)
                                        const model = propertiesData.textures.SKIN.metadata?.model // optional
                                        const capeUrl = convertUrlHttps(propertiesData.textures.CAPE?.url) // optional

                                        if(model === 'slim')
                                            slim = true

                                        if(skinUrl) {
                                            try {
                                                const parsedUrl = new URL(skinUrl)
                                                if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                                    try {
                                                        const response = await fetch(skinUrl)
                                                        if (response.ok) {
                                                            const contentType = response.headers.get("content-type") || ""
                                                            const blob = await response.blob()

                                                            // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                                            const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                                                && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                                    .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                                            if (contentType.includes("image/png") || isPngHeader) {
                                                                const objectUrl = URL.createObjectURL(blob)
                                                                await new Promise((resolve, reject) => {
                                                                    imgSkin.onload = () => {
                                                                        URL.revokeObjectURL(objectUrl)
                                                                        resolve(true)

                                                                        if (!testValidSkinSize(imgSkin.width,imgSkin.height))
                                                                            lbl = 'Skin must be a '+skinSizes+' PNG'
                                                                        else
                                                                            skinValid = true
                                                                    }
                                                                    imgSkin.onerror = () => {
                                                                        URL.revokeObjectURL(objectUrl)
                                                                        reject(false)
                                                                    }
                                                                    imgSkin.src = objectUrl
                                                                })
                                                            }
                                                        }
                                                    } catch {}
                                                }
                                            } catch {}
                                        }

                                        if(capeUrl) {
                                            fetchedProfileCapeExists = true
                                            try {
                                                const parsedUrl = new URL(capeUrl)
                                                if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                                    try {
                                                        const response = await fetch(capeUrl)
                                                        if (response.ok) {
                                                            const contentType = response.headers.get("content-type") || ""
                                                            const blob = await response.blob()

                                                            // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                                            const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                                                && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                                    .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                                            if (contentType.includes("image/png") || isPngHeader) {
                                                                const objectUrl = URL.createObjectURL(blob)
                                                                await new Promise((resolve, reject) => {
                                                                    fetchedProfileCapeImg.onload = () => {
                                                                        URL.revokeObjectURL(objectUrl)
                                                                        resolve(true)
                                                                    }
                                                                    fetchedProfileCapeImg.onerror = () => {
                                                                        URL.revokeObjectURL(objectUrl)
                                                                        reject(false)
                                                                    }
                                                                    fetchedProfileCapeImg.src = objectUrl
                                                                })
                                                            }
                                                        }
                                                    } catch {}
                                                }
                                            } catch {}
                                        }
                                    }
                                }
                            } catch {}
                        }
                        else {
                            lbl = 'Invalid username'
                        }
                    } catch {}

                    if(lbl === '') {
                        if(!accessedApi)
                            lbl = 'Failed to access skin server proxy'
                        else if(!skinValid)
                            lbl = 'Failed to fetch username: ' + username
                    }

                    await label('button-label', 'Validating inputs...')
                }
                else {
                    lbl = 'Failed to determine skin source'
                }

                if(skinValid) {
                    if(capeMode === 'file') {
                        if(selectedCapeFileSet && !testValidCapeSize(selectedCapeFileImg.width,selectedCapeFileImg.height))
                            lbl = 'Cape must be a '+capeSizes+' PNG'
                        else {
                            capeValid = true
                            hasCape = selectedCapeFileSet
                            imgCape = selectedCapeFileImg
                        }
                    }
                    else if(capeMode === 'username') {
                        if(usernameMode) {
                            if(fetchedProfileCapeExists) {
                                if (!testValidCapeSize(fetchedProfileCapeImg.width,fetchedProfileCapeImg.height))
                                    lbl = 'Cape must be a '+capeSizes+' PNG'
                                else {
                                    capeValid = true
                                    hasCape =  true
                                    imgCape = fetchedProfileCapeImg
                                }
                            }
                            else {
                                capeValid = true
                                hasCape = false
                            }
                        }
                        else {
                            capeValid = true
                            hasCape = false
                        }
                    }
                    else if(capeMode === 'preset') {
                        const url = document.getElementById('cape-preset-input').value
                        if(url === 'none') {
                            capeValid = true
                            hasCape = false
                        }
                        else {
                            await labelAndLog('button-label', 'Fetching cape...')

                            try {
                                const capeUrl = convertUrlHttps(url)
                                const parsedUrl = new URL(capeUrl)
                                if (parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:") {
                                    try {
                                        const response = await fetch(capeUrl)
                                        if (response.ok) {
                                            const contentType = response.headers.get("content-type") || ""
                                            const blob = await response.blob()

                                            // Fallback: treat as PNG if content-type is missing but the data starts with PNG signature
                                            const isPngHeader = (await blob.slice(0, 8).arrayBuffer())
                                                && new Uint8Array(await blob.slice(0, 8).arrayBuffer())
                                                    .every((b, i) => [137, 80, 78, 71, 13, 10, 26, 10][i] === b)
                                            if (contentType.includes("image/png") || isPngHeader) {
                                                const objectUrl = URL.createObjectURL(blob)
                                                await new Promise((resolve, reject) => {
                                                    imgCape.onload = () => {
                                                        URL.revokeObjectURL(objectUrl)
                                                        resolve(true)

                                                        if (!testValidCapeSize(imgCape.width,imgCape.height))
                                                            lbl = 'Cape must be a '+capeSizes+' PNG'
                                                        else {
                                                            capeValid = true
                                                            hasCape = true
                                                        }
                                                    }
                                                    imgCape.onerror = () => {
                                                        URL.revokeObjectURL(objectUrl)
                                                        reject(false)
                                                    }
                                                    imgCape.src = objectUrl
                                                })
                                            }
                                        }
                                    } catch {}
                                }
                            } catch {}

                            if(!capeValid && lbl === '') {
                                lbl = 'Failed to fetch preset cape: ' + document.getElementById('cape-preset-input').selectedOptions[0].text
                            }

                            await label('button-label', 'Validating inputs...')
                        }
                    }
                    else {
                        lbl = 'Failed to determine cape source'
                    }
                }

                if(lbl === '' && !(skinValid && capeValid))
                    lbl = 'Failed to validate inputs'

                if(skinValid && capeValid) {
                    await labelAndLog('button-label', 'Loading skin...')

                    console.log('Skin size: '+imgSkin.width+'x'+imgSkin.height)

                    if ((imgSkin.width !== imgSkin.height)) {
                        // see net.minecraft.client.renderer.texture.SkinTextureDownloader
                        console.log('Legacy skin detected, converting to new format')
                        const oldSkinResizeCanvas = createCanvas(imgSkin.width, imgSkin.width)
                        const oldSkinResizeCanvasCtx = getCanvasContext(oldSkinResizeCanvas)

                        oldSkinResizeCanvasCtx.drawImage(imgSkin, 0, 0)

                        const imageData = oldSkinResizeCanvasCtx.getImageData(imgSkin.width / 2, 0, imgSkin.width / 2, imgSkin.width / 2)
                        let hasTransparency = false
                        for (let i = 3; i < imageData.data.length; i += 4) {
                            if (imageData.data[i] < 128) {
                                hasTransparency = true
                                break
                            }
                        }

                        if (!hasTransparency) {
                            console.log('Archaic skin detected, removing hat layer')
                            const hatData = oldSkinResizeCanvasCtx.getImageData(imgSkin.width / 2, 0, imgSkin.width / 2, imgSkin.width / 4)
                            for (let i = 0; i < hatData.data.length; i += 4) {
                                hatData.data[i] = 0
                                hatData.data[i+1] = 0
                                hatData.data[i+2] = 0
                                hatData.data[i+3] = 0
                            }
                            oldSkinResizeCanvasCtx.putImageData(hatData, imgSkin.width / 2, 0)
                        }

                        const legacyCoordScale = imgSkin.width / vanillaSkinWidth

                        function copyRegion(inpSrcX, inpSrcY, inpDestDX, inpDestDY, inpWidth, inpHeight, mirrorX = false, mirrorY = false) {
                            const srcX = inpSrcX * legacyCoordScale
                            const srcY = inpSrcY * legacyCoordScale
                            const destDX = inpDestDX * legacyCoordScale
                            const destDY = inpDestDY * legacyCoordScale
                            const width = inpWidth * legacyCoordScale
                            const height = inpHeight * legacyCoordScale

                            const imageData = oldSkinResizeCanvasCtx.getImageData(srcX, srcY, width, height)
                            const out = oldSkinResizeCanvasCtx.createImageData(width, height)
                            const src = imageData.data
                            const dst = out.data

                            for (let y = 0; y < height; y++) {
                                for (let x = 0; x < width; x++) {
                                    const srcIndex = (y * width + x) * 4
                                    const dstX = mirrorX ? width - 1 - x : x
                                    const dstY = mirrorY ? height - 1 - y : y
                                    const dstIndex = (dstY * width + dstX) * 4
                                    dst[dstIndex] = src[srcIndex];
                                    dst[dstIndex + 1] = src[srcIndex + 1]
                                    dst[dstIndex + 2] = src[srcIndex + 2]
                                    dst[dstIndex + 3] = src[srcIndex + 3]
                                }
                            }

                            oldSkinResizeCanvasCtx.putImageData(out, srcX + destDX, srcY + destDY)
                        }

                        copyRegion(4, 16, 16, 32, 4, 4, true, false)
                        copyRegion(8, 16, 16, 32, 4, 4, true, false)
                        copyRegion(0, 20, 24, 32, 4, 12, true, false)
                        copyRegion(4, 20, 16, 32, 4, 12, true, false)
                        copyRegion(8, 20, 8, 32, 4, 12, true, false)
                        copyRegion(12, 20, 16, 32, 4, 12, true, false)
                        copyRegion(44, 16, -8, 32, 4, 4, true, false)
                        copyRegion(48, 16, -8, 32, 4, 4, true, false)
                        copyRegion(40, 20, 0, 32, 4, 12, true, false)
                        copyRegion(44, 20, -8, 32, 4, 12, true, false)
                        copyRegion(48, 20, -16, 32, 4, 12, true, false)
                        copyRegion(52, 20, -8, 32, 4, 12, true, false)

                        imgSkin = await new Promise(resolve => {
                            const newImg = new Image()
                            newImg.onload = () => resolve(newImg)
                            newImg.src = oldSkinResizeCanvas.toDataURL('image/png')
                        })
                    }       

                    const inputWidth = imgSkin.width
                    const inputHeight = imgSkin.height
                    const upscale = Math.floor((vanillaSkinWidth*pixelScale) / inputWidth)

                    const offset_3d_all = document.getElementById('shift-3d').value === 'all'
                    const offset_3d_head = offset_3d_all || document.getElementById('shift-3d').value === 'head'

                    const canvasSkin = createCanvas(vanillaSkinWidth*pixelScale, vanillaSkinHeight*pixelScale)
                    const canvasSkinCtx = getCanvasContext(canvasSkin)

                    const tmpCanvas = createCanvas(inputWidth, inputHeight)
                    const tmpCanvasCtx = getCanvasContext(tmpCanvas)
                    tmpCanvasCtx.drawImage(imgSkin, 0, 0)
                    const originalImageData = tmpCanvasCtx.getImageData(0, 0, inputWidth, inputHeight)
                    const scaledImageData = canvasSkinCtx.createImageData(vanillaSkinWidth*pixelScale, vanillaSkinHeight*pixelScale)

                    console.log('Scaling skin')
                    for (let y = 0; y < inputHeight; y++) {
                        for (let x = 0; x < inputWidth; x++) {
                            const index = (y * inputWidth + x) * 4
                            const r = originalImageData.data[index]
                            const g = originalImageData.data[index + 1]
                            const b = originalImageData.data[index + 2]
                            const a = originalImageData.data[index + 3]

                            for (let dy = 0; dy < upscale; dy++) {
                                for (let dx = 0; dx < upscale; dx++) {
                                    const scaledIndex = ((y * upscale + dy) * vanillaSkinWidth*pixelScale + (x * upscale + dx)) * 4
                                    scaledImageData.data[scaledIndex] = r
                                    scaledImageData.data[scaledIndex + 1] = g
                                    scaledImageData.data[scaledIndex + 2] = b
                                    scaledImageData.data[scaledIndex + 3] = a
                                }
                            }
                        }
                    }
                    canvasSkinCtx.putImageData(scaledImageData, 0, 0)

                    let canvasCape
                    if (hasCape) {
                        await labelAndLog('button-label', 'Loading cape...')
                        console.log('Cape size: '+imgCape.width+'x'+imgCape.height)
                        canvasCape = createCanvas(vanillaCapeWidth*pixelScale, vanillaCapeHeight*pixelScale)
                        const canvasCapeCtx = getCanvasContext(canvasCape)

                        const capeWidth = imgCape.width
                        const capeHeight = imgCape.height
                        const capeUpscale = Math.floor(vanillaCapeWidth*pixelScale / capeWidth)
                        const tmpCapeCanvas = createCanvas(capeWidth, capeHeight)
                        const tmpCapeCanvasCtx = getCanvasContext(tmpCapeCanvas)
                        tmpCapeCanvasCtx.drawImage(imgCape, 0, 0)
                        const capeData = tmpCapeCanvasCtx.getImageData(0, 0, capeWidth, capeHeight)
                        const scaledCapeData = canvasCapeCtx.createImageData(vanillaCapeWidth*pixelScale, vanillaCapeHeight*pixelScale)

                        console.log('Scaling cape')
                        for (let y = 0; y < capeHeight; y++) {
                            for (let x = 0; x < capeWidth; x++) {
                                const index = (y * capeWidth + x) * 4
                                const r = capeData.data[index]
                                const g = capeData.data[index + 1]
                                const b = capeData.data[index + 2]
                                const a = capeData.data[index + 3]

                                for (let dy = 0; dy < capeUpscale; dy++) {
                                    for (let dx = 0; dx < capeUpscale; dx++) {
                                        const scaledIndex = ((y * capeUpscale + dy) * vanillaCapeWidth*pixelScale + (x * capeUpscale + dx)) * 4
                                        scaledCapeData.data[scaledIndex] = r
                                        scaledCapeData.data[scaledIndex + 1] = g
                                        scaledCapeData.data[scaledIndex + 2] = b
                                        scaledCapeData.data[scaledIndex + 3] = a
                                    }
                                }
                            }
                        }
                        canvasCapeCtx.putImageData(scaledCapeData, 0, 0)
                    }

                    await labelAndLog('button-label', 'Slicing and dicing...')

                    function getSectionWidth(opsArray) {
                        let maxX = 0
                        for (const op of opsArray) {
                            const x1 = op.output.x
                            const x2 = op.output.x + Math.abs(op.input.dx * pixelScale)
                            maxX = Math.max(maxX, x2)
                        }
                        return maxX + extrudeAmount
                    }

                    function getSectionHeight(opsArray) {
                        let maxY = 0;
                        for (const op of opsArray) {
                            const y1 = op.output.y
                            const y2 = op.output.y + Math.abs(op.input.dy * pixelScale)
                            maxY = Math.max(maxY, y2)
                        }
                        return maxY + extrudeAmount
                    }

                    function drawSection(sourceCanvas, opsArray) {
                        return drawSectionPadded(0, sourceCanvas, opsArray)
                    }

                    function drawSectionPadded(extraWidth, sourceCanvas, opsArray) {
                        const width = getSectionWidth(opsArray) + (extraWidth * pixelScale)
                        const height = getSectionHeight(opsArray)

                        const canvas = createCanvas(width, height)
                        const canvasCtx = getCanvasContext(canvas)

                        for (const op of opsArray) {
                            if (op.input.dx === 0 || op.input.dy === 0) continue

                            const inputX = op.input.x * pixelScale
                            const inputY = op.input.y * pixelScale
                            const inputW = op.input.dx * pixelScale
                            const inputH = op.input.dy * pixelScale

                            const outputX = op.output.x
                            const outputY = op.output.y
                            const outputW = Math.abs(inputW)
                            const outputH = Math.abs(inputH)

                            canvasCtx.save()
                            canvasCtx.beginPath()
                            canvasCtx.rect(outputX, outputY, outputW, outputH)
                            canvasCtx.clip()

                            canvasCtx.translate(outputX + (inputW < 0 ? outputW : 0), outputY + (inputH < 0 ? outputH : 0))
                            canvasCtx.scale(inputW < 0 ? -1 : 1, inputH < 0 ? -1 : 1)

                            if (op.background) {
                                const argb = parseInt(op.background)
                                const a = ((argb >> 24) & 0xFF) / 255
                                const r = (argb >> 16) & 0xFF
                                const g = (argb >> 8) & 0xFF
                                const b = argb & 0xFF
                                canvasCtx.fillStyle = `rgba(${r},${g},${b},${a})`
                                canvasCtx.fillRect(0, 0, outputW, outputH)
                            }

                            {
                                const tempCanvas = createCanvas(outputW, outputH)
                                const tempCanvasCtx = getCanvasContext(tempCanvas)
                                tempCanvasCtx.drawImage(sourceCanvas, inputX, inputY, outputW, outputH, 0, 0, outputW, outputH)

                                const imgData = tempCanvasCtx.getImageData(0, 0, outputW, outputH)
                                for (let i = 3; i < imgData.data.length; i += 4) imgData.data[i] = 255
                                tempCanvasCtx.putImageData(imgData, 0, 0)

                                canvasCtx.drawImage(tempCanvas, 0, 0)
                            }

                            if (op.layer) {
                                const layerInputX = (op.input.x + (op.layer.dx ?? 0)) * pixelScale
                                const layerInputY = (op.input.y + (op.layer.dy ?? 0)) * pixelScale
                                const scale = op.layer.scale ?? 1

                                const layerWidth = outputW * scale
                                const layerHeight = outputH * scale

                                const layerDestX = (outputW - layerWidth) / 2
                                const layerDestY = (outputH - layerHeight) / 2

                                canvasCtx.drawImage(
                                    sourceCanvas,
                                    layerInputX,
                                    layerInputY,
                                    outputW,
                                    outputH,
                                    layerDestX,
                                    layerDestY,
                                    layerWidth,
                                    layerHeight
                                )
                            }

                            canvasCtx.restore()
                        }

                        return canvas
                    }

                    const x_offset = extrudeAmount
                    const y_offset = extrudeAmount

                    const tab_size = 4
                    const tab_small_size = 2
                    const tab_tiny_size = .666

                    const skinSections = []
                    const sectionFolds = []

                    function registerSectionFold(foldsList, fold) {
                        let thisDashed = true
                        if (fold.dashed === false)
                            thisDashed = false

                        if (fold.type === 'rect') {
                            if (fold.x === undefined || fold.y === undefined || fold.width === undefined || fold.height === undefined)
                                throw 'Invalid \'rect\' fold type to register'
                            
                            foldsList.push({
                                type: "rect",
                                dashed: thisDashed,
                                x: (fold.x * pixelScale) + extrudeAmount + (pixelScale * fold.tabWidth),
                                y: (fold.y * pixelScale) + extrudeAmount,
                                width: fold.width * pixelScale,
                                height: fold.height * pixelScale
                            })

                            if (fold.extend) {
                                if (fold.extend.left > 0) {
                                    const extendFold = fold.extend.left
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x,
                                        y: fold.y,
                                        dx: -1 * extendFold,
                                        dy: extendFold / 2,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x,
                                        y: fold.y + fold.height,
                                        dx: -1 * extendFold,
                                        dy: -1 * extendFold / 2,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + (-1 * extendFold),
                                        y: fold.y + (extendFold / 2),
                                        dx: 0,
                                        dy: fold.height + (-1 * extendFold),
                                    })
                                }
                                if (fold.extend.right > 0) {
                                    const extendFold = fold.extend.right
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + fold.width,
                                        y: fold.y,
                                        dx: extendFold,
                                        dy: extendFold / 2,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + fold.width,
                                        y: fold.y + fold.height,
                                        dx: extendFold,
                                        dy: -1 * extendFold / 2,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + fold.width + extendFold,
                                        y: fold.y + (extendFold / 2),
                                        dx: 0,
                                        dy: fold.height + (-1 * extendFold),
                                    })
                                }
                                if (fold.extend.top > 0) {
                                    const extendFold = fold.extend.top
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x,
                                        y: fold.y,
                                        dx: extendFold / 2,
                                        dy: -1 * extendFold,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + fold.width,
                                        y: fold.y,
                                        dx: -1 * extendFold / 2,
                                        dy: -1 * extendFold,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + (extendFold / 2),
                                        y: fold.y + (-1 * extendFold),
                                        dx: fold.width + (-1 * extendFold),
                                        dy: 0,
                                    })
                                }
                                if (fold.extend.bottom > 0) {
                                    const extendFold = fold.extend.bottom
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x,
                                        y: fold.y + fold.height,
                                        dx: extendFold / 2,
                                        dy: extendFold,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + fold.width,
                                        y: fold.y + fold.height,
                                        dx: -1 * extendFold / 2,
                                        dy: extendFold,
                                    })
                                    registerSectionFold(foldsList, {
                                        type: "line",
                                        tabWidth: fold.tabWidth,
                                        dashed: false,
                                        x: fold.x + (extendFold / 2),
                                        y: fold.y + fold.height + extendFold,
                                        dx: fold.width + (-1 * extendFold),
                                        dy: 0,
                                    })
                                }
                            }
                        }
                        else if (fold.type === 'line') {
                            if (fold.x === undefined || fold.y === undefined || fold.dx === undefined || fold.dy === undefined)
                                throw 'Invalid \'line\' fold type to register'
                            
                            foldsList.push({
                                type: "line",
                                dashed: thisDashed,
                                x: (fold.x * pixelScale) + extrudeAmount + (pixelScale * fold.tabWidth),
                                y: (fold.y * pixelScale) + extrudeAmount,
                                dx: fold.dx * pixelScale,
                                dy: fold.dy * pixelScale
                            })
                        }
                        else
                            throw 'Failed to read fold type to register: ' + fold.type
                    }

                    function registerSectionFolds(list) {
                        let thisSection = {folds:[]}
                        list.forEach(fold => {
                            registerSectionFold(thisSection.folds, fold)
                        })
                        sectionFolds.push(thisSection)
                    }

                    // Head
                    skinSections.push(drawSection(canvasSkin, [
                        { input: { x: 0, y: 8, dx: 8, dy: 8 }, output: { x: x_offset+tab_size*pixelScale, y: y_offset+8*pixelScale },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                        { input: { x: 8, y: 8, dx: 8, dy: 8 }, output: { x: x_offset+tab_size*pixelScale+8*pixelScale, y: y_offset+8*pixelScale },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                        { input: { x: 16, y: 8, dx: 8, dy: 8 }, output: { x: x_offset+tab_size*pixelScale+16*pixelScale, y: y_offset+8*pixelScale },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                        { input: { x: 24, y: 8, dx: 8, dy: 8 }, output: { x: x_offset+tab_size*pixelScale+24*pixelScale, y: y_offset+8*pixelScale },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                        { input: { x: 8, y: 0, dx: 8, dy: 8 }, output: { x: x_offset+(tab_size+8)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                        { input: { x: 16, y: 0, dx: 8, dy: -8 }, output: { x: x_offset+(tab_size+8)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dx: 32, scale: offset_3d_head ? ((8+.5)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_size, x: 0, y: 8, width: 8, height: 8, extend: {left: tab_size, top: tab_size, bottom: tab_size}},
                        {type: "rect", tabWidth: tab_size, x: 8, y: 8, width: 8, height: 8},
                        {type: "rect", tabWidth: tab_size, x: 16, y: 8, width: 8, height: 8, extend: {top: tab_size, bottom: tab_size}},
                        {type: "rect", tabWidth: tab_size, x: 24, y: 8, width: 8, height: 8, extend: {top: tab_size, bottom: tab_size}},
                        {type: "rect", tabWidth: tab_size, x: 8, y: 0, width: 8, height: 8},
                        {type: "rect", tabWidth: tab_size, x: 8, y: 16, width: 8, height: 8},
                    ])

                    // Body
                    skinSections.push(drawSection(canvasSkin, [
                        { input: { x: 16, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_size*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 20, y: 20, dx: 8, dy: 12 }, output: { x: x_offset+tab_size*pixelScale+4*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 28, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_size*pixelScale+12*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 32, y: 20, dx: 8, dy: 12 }, output: { x: x_offset+tab_size*pixelScale+16*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 20, y: 16, dx: 8, dy: 4 }, output: { x: x_offset+(tab_size+4)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 28, y: 16, dx: 8, dy: -4 }, output: { x: x_offset+(tab_size+4)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_size, x: 0, y: 4, width: 4, height: 12, extend: {left: tab_size, top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_size, x: 4, y: 4, width: 8, height: 12},
                        {type: "rect", tabWidth: tab_size, x: 12, y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_size, x: 16, y: 4, width: 8, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_size, x: 4, y: 0, width: 8, height: 4},
                        {type: "rect", tabWidth: tab_size, x: 4, y: 16, width: 8, height: 4},
                    ])

                    // Right Arm
                    skinSections.push(drawSectionPadded((slim ? 2 : 0), canvasSkin, [
                        { input: { x: 40, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 44, y: 20, dx: (slim ? 3 : 4), dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+4*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 44 + (slim ? 3 : 4), y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+(4 + (slim ? 3 : 4))*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 44 + (slim ? 3 : 4) + 4, y: 20, dx: (slim ? 3 : 4), dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+(4 + (slim ? 3 : 4) + 4)*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 44, y: 16, dx: (slim ? 3 : 4), dy: 4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 48 - (slim ? 1 : 0), y: 16, dx: (slim ? 3 : 4), dy: -4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_small_size, x: 0, y: 4, width: 4, height: 12, extend: {left: tab_small_size, top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 4, width: (slim ? 3 : 4), height: 12},
                        {type: "rect", tabWidth: tab_small_size, x: 4 + (slim ? 3 : 4), y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4 + (slim ? 3 : 4) + 4, y: 4, width: (slim ? 3 : 4), height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 0, width: (slim ? 3 : 4), height: 4},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 16, width: (slim ? 3 : 4), height: 4},
                    ])

                    // Left Arm
                    skinSections.push(drawSectionPadded((slim ? 2 : 0), canvasSkin, [
                        { input: { x: 32, y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 36, y: 52, dx: (slim ? 3 : 4), dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+4*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 36 + (slim ? 3 : 4), y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+(4 + (slim ? 3 : 4))*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 36 + (slim ? 3 : 4) + 4, y: 52, dx: (slim ? 3 : 4), dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+(4 + (slim ? 3 : 4) + 4)*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 36, y: 48, dx: (slim ? 3 : 4), dy: 4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 40 - (slim ? 1 : 0), y: 48, dx: (slim ? 3 : 4), dy: -4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dx: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_small_size, x: 0, y: 4, width: 4, height: 12, extend: {left: tab_small_size, top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 4, width: (slim ? 3 : 4), height: 12},
                        {type: "rect", tabWidth: tab_small_size, x: 4 + (slim ? 3 : 4), y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4 + (slim ? 3 : 4) + 4, y: 4, width: (slim ? 3 : 4), height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 0, width: (slim ? 3 : 4), height: 4},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 16, width: (slim ? 3 : 4), height: 4},
                    ])

                    // Right Leg
                    skinSections.push(drawSection(canvasSkin, [
                        { input: { x: 0, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 4, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+4*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 8, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+8*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 12, y: 20, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+12*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 4, y: 16, dx: 4, dy: 4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 8, y: 16, dx: 4, dy: -4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dy: 16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_small_size, x: 0, y: 4, width: 4, height: 12, extend: {left: tab_small_size, top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 4, width: 4, height: 12},
                        {type: "rect", tabWidth: tab_small_size, x: 8, y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 12, y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 0, width: 4, height: 4},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 16, width: 4, height: 4},
                    ])

                    // Left Leg
                    skinSections.push(drawSection(canvasSkin, [
                        { input: { x: 16, y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1  } },
                        { input: { x: 20, y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+4*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1  } },
                        { input: { x: 24, y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+8*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1  } },
                        { input: { x: 28, y: 52, dx: 4, dy: 12 }, output: { x: x_offset+tab_small_size*pixelScale+12*pixelScale, y: y_offset+4*pixelScale },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1  } },
                        { input: { x: 20, y: 48, dx: 4, dy: 4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                        { input: { x: 24, y: 48, dx: 4, dy: -4 }, output: { x: x_offset+(tab_small_size+4)*pixelScale, y: y_offset+16*pixelScale },
                            background: "0xFF000000", layer: { dx: -16, scale: offset_3d_all ? ((8+.25)/8) : 1 } },
                    ]))
                    registerSectionFolds([
                        {type: "rect", tabWidth: tab_small_size, x: 0, y: 4, width: 4, height: 12, extend: {left: tab_small_size, top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 4, width: 4, height: 12},
                        {type: "rect", tabWidth: tab_small_size, x: 8, y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 12, y: 4, width: 4, height: 12, extend: {top: tab_small_size, bottom: tab_small_size}},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 0, width: 4, height: 4},
                        {type: "rect", tabWidth: tab_small_size, x: 4, y: 16, width: 4, height: 4},
                    ])

                    // Cape
                    if (hasCape) {
                        skinSections.push(drawSection(canvasCape, [
                            {  file:"cape", input: { x: 0, y: 1, dx: 1, dy: 16 }, output: { x: x_offset+tab_size*pixelScale, y: y_offset+1*pixelScale },
                                background: "0xFF000000" },
                            {  file:"cape", input: { x: 1, y: 1, dx: 10, dy: 16 }, output: { x: x_offset+tab_size*pixelScale+1*pixelScale, y: y_offset+1*pixelScale },
                                background: "0xFF000000" },
                            {  file:"cape", input: { x: 11, y: 1, dx: 1, dy: 16 }, output: { x: x_offset+tab_size*pixelScale+11*pixelScale, y: y_offset+1*pixelScale },
                                background: "0xFF000000" },
                            {  file:"cape", input: { x: 12, y: 1, dx: 10, dy: 16 }, output: { x: x_offset+tab_size*pixelScale+12*pixelScale, y: y_offset+1*pixelScale },
                                background: "0xFF000000" },
                            {  file:"cape", input: { x: 1, y: 0, dx: 10, dy: 1 }, output: { x: x_offset+(tab_size+1)*pixelScale, y: y_offset },
                                background: "0xFF000000" },
                            {  file:"cape", input: { x: 11, y: 0, dx: 10, dy: -1 }, output: { x: x_offset+(tab_size+1)*pixelScale, y: y_offset+17*pixelScale },
                                background: "0xFF000000" },
                        ]))
                        registerSectionFolds([
                            {type: "rect", tabWidth: tab_size, x: 0, y: 1, width: 1, height: 16, extend: {left: tab_size, top: tab_tiny_size, bottom: tab_tiny_size}},
                            {type: "rect", tabWidth: tab_size, x: 1, y: 1, width: 10, height: 16},
                            {type: "rect", tabWidth: tab_size, x: 11, y: 1, width: 1, height: 16, extend: {top: tab_tiny_size, bottom: tab_tiny_size}},
                            {type: "rect", tabWidth: tab_size, x: 12, y: 1, width: 10, height: 16, extend: {top: tab_tiny_size, bottom: tab_tiny_size}},
                            {type: "rect", tabWidth: tab_size, x: 1, y: 0, width: 10, height: 1},
                            {type: "rect", tabWidth: tab_size, x: 1, y: 17, width: 10, height: 1},
                        ])
                    }

                    await labelAndLog('button-label', 'Organizing pages...')

                    function extrudeCanvasEdges(extrudeCanvas) {
                        const extrudeCtx = getCanvasContext(extrudeCanvas)
                        const w = extrudeCanvas.width
                        const h = extrudeCanvas.height

                        const src = extrudeCtx.getImageData(0, 0, w, h)
                        const srcData = src.data

                        const dist = new Int32Array(w * h).fill(-1)
                        const srcId = new Int32Array(w * h).fill(-1)
                        const srcColors = []
                        const queue = []

                        const idx = (x, y) => y * w + x
                        const inBounds = (x, y) => x >= 0 && y >= 0 && x < w && y < h

                        // Initialize queues and color mapping
                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const i = idx(x, y);
                                if (srcData[i * 4 + 3] !== 0) {
                                    const id = srcColors.length
                                    srcColors.push([
                                        srcData[i * 4 + 0],
                                        srcData[i * 4 + 1],
                                        srcData[i * 4 + 2],
                                        srcData[i * 4 + 3],
                                    ])
                                    dist[i] = 0
                                    srcId[i] = id
                                    queue.push(i)
                                }
                            }
                        }

                        for (let qIndex = 0; qIndex < queue.length; qIndex++) {
                            const cur = queue[qIndex]
                            const cx = cur % w
                            const cy = Math.floor(cur / w)
                            const curDist = dist[cur]
                            if (curDist >= extrudeAmount) continue

                            const neighbors = [
                                [cx - 1, cy],
                                [cx + 1, cy],
                                [cx, cy - 1],
                                [cx, cy + 1],
                            ]
                            for (const [nx, ny] of neighbors) {
                                if (!inBounds(nx, ny)) continue
                                const ni = idx(nx, ny)
                                if (dist[ni] === -1) {
                                    dist[ni] = curDist + 1
                                    srcId[ni] = srcId[cur]
                                    queue.push(ni)
                                }
                            }
                        }

                        const dst = extrudeCtx.createImageData(w, h)
                        dst.data.set(srcData)

                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const i = idx(x, y)
                                if (dist[i] > 0 && dist[i] <= extrudeAmount) {
                                    const color = srcColors[srcId[i]]
                                    dst.data[i * 4 + 0] = color[0]
                                    dst.data[i * 4 + 1] = color[1]
                                    dst.data[i * 4 + 2] = color[2]
                                    dst.data[i * 4 + 3] = color[3]
                                }
                            }
                        }

                        extrudeCtx.putImageData(dst, 0, 0)
                    }

                    const pageSections = []
                    let currentPage = createCanvas(outputWidth, outputHeight)
                    let currentPageCtx = getCanvasContext(currentPage)

                    let x = pageMarginX
                    let y = pageMarginY
                    let rowHeight = 0

                    let sectionNum = 0
                    for (const section of skinSections) {
                        if (x + section.width + pageMarginX > outputWidth) {
                            if(pageMarginX + section.width + pageMarginX > outputWidth) {
                                throw "pixelScaleInput '"+pixelScaleInput+"' too high for outputWidth '"+outputWidth+"'"
                            }
                            x = pageMarginX
                            y += rowHeight + spacing
                            rowHeight = 0
                        }

                        if (y + section.height + pageMarginY > outputHeight) {
                            if(pageMarginY + section.height + pageMarginY > outputHeight) {
                                throw "pixelScaleInput '"+pixelScaleInput+"' too high for outputHeight '"+outputHeight+"'"
                            }
                            pageSections.push(currentPage)
                            currentPage = createCanvas(outputWidth, outputHeight)
                            currentPageCtx = getCanvasContext(currentPage)
                            x = pageMarginX
                            y = pageMarginY
                            rowHeight = 0
                        }

                        currentPageCtx.drawImage(section, x, y)

                        sectionFolds[sectionNum].page = pageSections.length
                        sectionFolds[sectionNum].x = x
                        sectionFolds[sectionNum].y = y

                        x += section.width + spacing
                        rowHeight = Math.max(rowHeight, section.height)
                        sectionNum++
                    }

                    pageSections.push(currentPage)

                    await labelAndLog('button-label', 'Doubling sides...')

                    const pageSectionsDouble = []
                    pageSections.forEach(c => {
                        pageSectionsDouble.push(c)

                        const backPage = createCanvas(c.width, c.height)
                        const backPageCtx = getCanvasContext(backPage)

                        if (!disableDoubleSided) {
                            backPageCtx.translate(backPage.width, 0)
                            backPageCtx.scale(-1, 1)
                        }
                        backPageCtx.drawImage(c, 0, 0)

                        pageSectionsDouble.push(backPage)
                    })

                    if (extrudeEdges) {
                        await labelAndLog('button-label', 'Extruding edges...')
                        pageSections.forEach(c => extrudeCanvasEdges(c))
                    }

                    await labelAndLog('button-label', 'Drawing fold lines...')

                    function drawAlignedDottedLine(ctx, dir, dashed, x1, y1, x2, y2) {
                        const isVertical = Math.abs(x2 - x1) < Math.abs(y2 - y1)
                        if(isVertical != dir)
                            return

                        if (x1 === x2 && y1 === y2)
                            return

                        if (dashed && !showDashedLines)
                            return

                        // make sure dash colors always go same direction
                        if(y1 === y2 && x2 < x1) {
                            let temp = x2
                            x2 = x1
                            x1 = temp
                        }
                        if(x1 === x2 && y2 < y1) {
                            let temp = y2
                            y2 = y1
                            y1 = temp
                        }

                        const dx = x2 - x1
                        const dy = y2 - y1
                        const totalLength = Math.hypot(dx, dy)

                        const dirX = dx / totalLength
                        const dirY = dy / totalLength

                        const startCoord = (isVertical ? (y1 - pageMarginY) : (x1 - pageMarginX)) - (pixelScale / 4)
                        const phaseOffset = (startCoord % (2 * dottedPixelLength) + 2 * dottedPixelLength) % (2 * dottedPixelLength)

                        ctx.beginPath()
                        ctx.moveTo(x1, y1)
                        ctx.lineTo(x2, y2)

                        ctx.save()
                        ctx.globalCompositeOperation = 'destination-out'
                        ctx.strokeStyle = '#000'
                        ctx.lineCap = 'square'
                        ctx.stroke()
                        ctx.restore()

                        ctx.save()
                        ctx.globalCompositeOperation = dashed ? 'source-over' : 'destination-over'
                        ctx.strokeStyle = dashed ? dottedColorB : solidColor
                        ctx.lineCap = 'square'
                        ctx.stroke()
                        ctx.restore()

                        if (dashed) {
                            let dist = 0
                            while (dist < totalLength) {
                                const coord = (phaseOffset + dist) % (2 * dottedPixelLength)
                                const colorIndex = Math.floor(coord / dottedPixelLength) % 2

                                const nextBoundary =
                                    Math.min(
                                        dist + (dottedPixelLength - (coord % dottedPixelLength)),
                                        totalLength
                                    )

                                const sx = x1 + dirX * dist
                                const sy = y1 + dirY * dist
                                const ex = x1 + dirX * nextBoundary
                                const ey = y1 + dirY * nextBoundary

                                ctx.beginPath()
                                ctx.moveTo(sx, sy)
                                ctx.lineTo(ex, ey)

                                ctx.save()
                                ctx.globalCompositeOperation = 'destination-out'
                                ctx.strokeStyle = '#000'
                                ctx.stroke()
                                ctx.restore()

                                ctx.save()
                                ctx.globalCompositeOperation = 'source-over'
                                ctx.strokeStyle = colorIndex === 0 ? dottedColorA : dottedColorB
                                ctx.stroke()
                                ctx.restore()

                                dist = nextBoundary
                            }
                        }
                    }

                    function drawFoldLines(ctx, thisSection, fold, dir) {
                        if (fold.type === 'rect') {
                            drawAlignedDottedLine(ctx, dir, fold.dashed, thisSection.x + fold.x, thisSection.y + fold.y, thisSection.x + fold.x + fold.width, thisSection.y + fold.y)
                            drawAlignedDottedLine(ctx, dir, fold.dashed, thisSection.x + fold.x, thisSection.y + fold.y, thisSection.x + fold.x, thisSection.y + fold.y + fold.height)
                            drawAlignedDottedLine(ctx, dir, fold.dashed, thisSection.x + fold.x + fold.width, thisSection.y + fold.y + fold.height, thisSection.x + fold.x + fold.width, thisSection.y + fold.y)
                            drawAlignedDottedLine(ctx, dir, fold.dashed, thisSection.x + fold.x + fold.width, thisSection.y + fold.y + fold.height, thisSection.x + fold.x, thisSection.y + fold.y + fold.height)
                        } else if (fold.type === 'line') {
                            drawAlignedDottedLine(ctx, dir, fold.dashed, thisSection.x + fold.x, thisSection.y + fold.y, thisSection.x + fold.x + fold.dx, thisSection.y + fold.y + fold.dy)
                        }
                        else
                            throw 'Failed to read fold type to draw: ' + fold.type
                    }

                    const sectionFoldOverlays = []
                    for (let i = 0; i < pageSections.length; i++) {
                        sectionFoldOverlays.push(createCanvas(outputWidth, outputHeight))
                    }

                    for (let i = 0; i < sectionFolds.length; i++) {
                        let thisSection = sectionFolds[i]
                        if (thisSection.page === undefined || thisSection.x === undefined || thisSection.y === undefined || thisSection.folds === undefined)
                            throw 'Error generating fold lines'
                        let ctx = getCanvasContext(sectionFoldOverlays[thisSection.page])
                        ctx.lineWidth = dottedPixelWidth
                        ctx.globalCompositeOperation = 'destination-over'
                        thisSection.folds.forEach(fold => {
                            drawFoldLines(ctx, thisSection, fold, true)
                        })
                        thisSection.folds.forEach(fold => {
                            drawFoldLines(ctx, thisSection, fold, false)
                        })
                    }

                    for (let i = 0; i < pageSections.length; i++) {
                        const baseCtx = getCanvasContext(pageSectionsDouble[(2 * i) + 1])
                        const overlay = sectionFoldOverlays[i]
                        baseCtx.drawImage(overlay, 0, 0)
                    }

                    await labelAndLog('button-label', 'Generating PDF...')

                    while (!window.jspdf) {
                        await new Promise(r => setTimeout(r, 50))
                    }

                    const { jsPDF } = window.jspdf

                    let newPdf = new jsPDF({
                        orientation: 'portrait',
                        unit: outputUnitLabel,
                        format: [outputUnitWidth, outputUnitHeight],
                        compress: false
                    })

                    const safeAreaX = outputWidth - (2 * pageMarginX)
                    const safeAreaY = outputHeight - (2 * pageMarginY)
                    const safeAreaUnitX = outputUnitWidth - (2 * pageMarginUnitX)
                    const safeAreaUnitY = outputUnitHeight - (2 * pageMarginUnitY)

                    if (disableDoubleSided) {
                        let tempList = []
                        for (let i = 0; i < pageSections.length; i++)
                            tempList.push(pageSectionsDouble[(2 * i) + 1])
                        pageSectionsDouble.length = 0
                        pageSectionsDouble.push(...tempList)
                    }

                    pageSectionsDouble.forEach((canvas, i) => {
                        if (i > 0)
                            newPdf.addPage()

                        const pdfPageCanvas = createCanvas(safeAreaX, safeAreaY)
                        const pdfPageCanvasCtx = getCanvasContext(pdfPageCanvas)
                        pdfPageCanvasCtx.fillStyle = pageColor
                        pdfPageCanvasCtx.fillRect(0, 0, safeAreaX, safeAreaY)
                        pdfPageCanvasCtx.drawImage(canvas, pageMarginX, pageMarginY, safeAreaX, safeAreaY, 0, 0, safeAreaX, safeAreaY)

                        newPdf.addImage(
                            pdfPageCanvas.toDataURL('image/jpeg', 0.8),
                            'JPEG',
                            pageMarginUnitX,
                            pageMarginUnitY,
                            safeAreaUnitX,
                            safeAreaUnitY
                        )
                    })

                    generatedPdf = newPdf

                    let newHtml = ''
                    newHtml += '<br/>'
                    newHtml += '<button class="button" onClick="openPdf()" style="font-size:x-large">Open PDF</button>'
                    newHtml += '<br/>'
                    newHtml += '<table class="card-table"><tr class="card-table-row">'
                    for (const page of pageSectionsDouble) {
                        prevPageCount++
                        newHtml += `<td class="card-wrap-any"><img src="${page.toDataURL('image/png')}" class="img-mostly"></td>`
                    }
                    newHtml += '</tr></table>'

                    document.getElementById('img-span').innerHTML = newHtml
                    label('button-label', '')

                    console.log('Generate function completed')
                }
                else {
                    if(lbl === '')
                        await labelAndLog('button-label', 'Input error')
                    else
                        await labelAndLog('button-label', 'Inputs invalid: '+lbl)
                    document.getElementById('img-span').innerHTML = ''
                }
            } catch (err) {
                await label('button-label', 'Error:\n'+err)
                throw err
            }
        }

        function openPdf() {
            if (!generatedPdf)
                return
            const pdfBlob = generatedPdf.output('bloburl');
            window.open(pdfBlob, '_blank');
        }

    </script>

</body>
</html>